import pygame
import sys
import math
sys.setrecursionlimit(10**7)

pygame.init()

# =============================
# GLOBAL SETTINGS
# =============================
WIDTH, HEIGHT = 1000, 720
SCREEN = pygame.display.set_mode((WIDTH, HEIGHT))
pygame.display.set_caption("SINGLE-LINE FILL PUZZLE SOLVER")

FONT = pygame.font.SysFont("arial", 24)
SMALL = pygame.font.SysFont("arial", 20)

COLOR_BG = (25, 25, 25)
COLOR_BOX = (50, 50, 50)
COLOR_ACTIVE = (80, 80, 200)
COLOR_TEXT = (240, 240, 240)

COLOR_BTN = (70, 170, 70)
COLOR_BTN2 = (170, 70, 70)
COLOR_GRID = (180, 180, 180)
COLOR_OBS = (220, 50, 50)
COLOR_START_FIN = (0, 255, 0)
COLOR_EMPTY = (200, 200, 200)
COLOR_NUM = (0, 120, 255)

# =============================
# TEXTBOX CLASS
# =============================
class TextBox:
    def __init__(self, x, y, w, h):
        self.rect = pygame.Rect(x, y, w, h)
        self.color = COLOR_BOX
        self.text = ""
        self.active = False

    def handle_event(self, event):
        if event.type == pygame.MOUSEBUTTONDOWN:
            self.active = self.rect.collidepoint(event.pos)
            self.color = COLOR_ACTIVE if self.active else COLOR_BOX

        if event.type == pygame.KEYDOWN and self.active:
            if event.key == pygame.K_BACKSPACE:
                self.text = self.text[:-1]
            elif event.unicode.isdigit():
                self.text += event.unicode

    def draw(self, screen):
        pygame.draw.rect(screen, self.color, self.rect, border_radius=4)
        txt_surface = FONT.render(self.text, True, COLOR_TEXT)
        screen.blit(txt_surface, (self.rect.x + 5, self.rect.y + 5))


# =============================
# MENU AWAL
# =============================
def draw_label(text, x, y):
    img = FONT.render(text, True, COLOR_TEXT)
    SCREEN.blit(img, (x, y))


def start_menu():
    row_box = TextBox(350, 180, 200, 40)
    col_box = TextBox(350, 260, 200, 40)
    obs_box = TextBox(350, 340, 200, 40)

    start_button = pygame.Rect(350, 440, 200, 50)

    while True:
        SCREEN.fill(COLOR_BG)

        draw_label("Rows:", 250, 185)
        draw_label("Columns:", 250, 265)
        draw_label("Obstacles:", 250, 345)

        row_box.draw(SCREEN)
        col_box.draw(SCREEN)
        obs_box.draw(SCREEN)

        pygame.draw.rect(SCREEN, COLOR_BTN, start_button, border_radius=6)
        SCREEN.blit(FONT.render("START", True, (255,255,255)),
                    (start_button.x+60, start_button.y+10))

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()

            row_box.handle_event(event)
            col_box.handle_event(event)
            obs_box.handle_event(event)

            if event.type == pygame.MOUSEBUTTONDOWN:
                if start_button.collidepoint(event.pos):
                    if row_box.text and col_box.text and obs_box.text:
                        return int(row_box.text), int(col_box.text), int(obs_box.text)

        pygame.display.update()


# =============================
# DFS SOLVER
# =============================
def find_points(g):
    pts = []
    R, C = len(g), len(g[0])
    for r in range(R):
        for c in range(C):
            if g[r][c] == "A":
                pts.append((r,c))
    if len(pts) != 2:
        return None, None
    return pts[0], pts[1]


def dfs_solver(grid):
    R, C = len(grid), len(grid[0])
    start, finish = find_points(grid)
    if not start or not finish:
        return None

    dirs = [(1,0),(-1,0),(0,1),(0,-1)]

    target_cells = [(r,c) for r in range(R) for c in range(C)
                    if grid[r][c] in ("0","A")]
    need = len(target_cells)

    visited = set()
    path = []
    solution = None

    def degree(r,c):
        cnt = 0
        for dr,dc in dirs:
            nr, nc = r+dr, c+dc
            if 0 <= nr < R and 0 <= nc < C:
                if grid[nr][nc] != "X" and (nr,nc) not in visited:
                    cnt += 1
        return cnt

    def dfs(r,c):
        nonlocal solution
        if solution is not None:
            return

        if (r,c) == finish and len(path) == need:
            solution = path[:]
            return

        moves = []
        for dr,dc in dirs:
            nr, nc = r+dr, c+dc
            if 0 <= nr < R and 0 <= nc < C:
                if grid[nr][nc] != "X" and (nr,nc) not in visited:
                    moves.append((degree(nr,nc), nr, nc))

        moves.sort()

        for _, nr, nc in moves:
            visited.add((nr,nc))
            path.append((nr,nc))

            dfs(nr,nc)

            path.pop()
            visited.remove((nr,nc))

    visited.add(start)
    path.append(start)
    dfs(*start)

    return solution


# =============================
# DRAWING
# =============================
def draw_grid(rows, cols, cs, grid):
    for r in range(rows):
        for c in range(cols):
            rect = pygame.Rect(c*cs, r*cs, cs, cs)

            if grid[r][c] == "X":
                pygame.draw.rect(SCREEN, COLOR_OBS, rect)
            elif grid[r][c] == "A":
                pygame.draw.rect(SCREEN, COLOR_START_FIN, rect)
            else:
                pygame.draw.rect(SCREEN, COLOR_EMPTY, rect)

            pygame.draw.rect(SCREEN, COLOR_GRID, rect, 1)


# =============================
# DRAW PATH 
# =============================

def cell_center(r, c, cs):
    return (c * cs + cs // 2, r * cs + cs // 2)


def draw_path(path, cs):
    if not path or len(path) < 2:
        return

    points = []

    # --- START ---
    (r0, c0) = path[0]
    (r1, c1) = path[1]

    x0 = c0 * cs + cs // 2
    y0 = r0 * cs + cs // 2

    # arah dari start ke node pertama
    dx = c1 - c0
    dy = r1 - r0

    # geser titik start ke pinggir sel hijau
    x0 += dx * (cs // 2 - 2)
    y0 += dy * (cs // 2 - 2)

    points.append((x0, y0))

    # --- MIDDLE ---
    for (r, c) in path[1:-1]:
        points.append(cell_center(r, c, cs))

    # --- FINISH ---
    (rf, cf) = path[-1]
    (r_prev, c_prev) = path[-2]

    xf = cf * cs + cs // 2
    yf = rf * cs + cs // 2

    dx = c_prev - cf
    dy = r_prev - rf

    # geser titik akhir supaya berhenti di tepi sel hijau
    xf += dx * (cs // 2 - 2)
    yf += dy * (cs // 2 - 2)

    points.append((xf, yf))

    # Finally draw the path
    pygame.draw.lines(SCREEN, (0, 70, 255), False, points, 10)


# =============================
# ALERT IF NO SOLUTION
# =============================

def show_alert(message):
    popup_width, popup_height = 400, 200
    popup = pygame.Surface((popup_width, popup_height))

    ok_rect = pygame.Rect(
        popup_width//2 - 50,
        120,
        100,
        40
    )

    running = True
    while running:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()

            if event.type == pygame.MOUSEBUTTONDOWN:
                mx, my = event.pos

                # hitbox relatif terhadap popup
                rel_x = mx - (WIDTH//2 - popup_width//2)
                rel_y = my - (HEIGHT//2 - popup_height//2)

                if ok_rect.collidepoint((rel_x, rel_y)):
                    running = False   # pop-up hilang

        popup.fill((40, 40, 40))
        pygame.draw.rect(popup, (200, 50, 50), (0, 0, popup_width, popup_height), 4)

        txt = FONT.render(message, True, (255,255,255))
        popup.blit(txt, (popup_width//2 - txt.get_width()//2, 50))

        pygame.draw.rect(popup, (100,200,100), ok_rect, border_radius=8)
        popup.blit(FONT.render("OK", True, (0,0,0)),
                   (ok_rect.x + 30, ok_rect.y + 5))

        SCREEN.blit(
            popup,
            (WIDTH//2 - popup_width//2,
             HEIGHT//2 - popup_height//2)
        )

        pygame.display.update()


# -----------------------
# history helpers (UNDO/REDO)
# -----------------------

def copy_grid(g):
    return [row[:] for row in g]

def make_snapshot(grid, start, finish, obs_count):
    return {
        "grid": copy_grid(grid),
        "start": None if start is None else (start[0], start[1]),
        "finish": None if finish is None else (finish[0], finish[1]),
        "obs": obs_count
    }

def restore_snapshot(snap):
    # returns grid, start, finish, obs_count
    g = copy_grid(snap["grid"])
    s = None if snap["start"] is None else (snap["start"][0], snap["start"][1])
    f = None if snap["finish"] is None else (snap["finish"][0], snap["finish"][1])
    return g, s, f, snap["obs"]


# =============================
# HOVER ANIMATION
# =============================

def lerp(a, b, t):
    return a + (b - a) * t

def lerp_color(c1, c2, t):
    return (
        int(lerp(c1[0], c2[0], t)),
        int(lerp(c1[1], c2[1], t)),
        int(lerp(c1[2], c2[2], t)),
    )


# =============================
# MAIN GRID EDITOR
# =============================
def main_editor(rows, cols, max_obs):
    grid = [["0" for _ in range(cols)] for _ in range(rows)]
    cs = min(600//rows, 600//cols)

    mode = "none"
    obs_count = 0
    start = None
    finish = None

    undo = []
    redo = []

    buttons = {
        "home": pygame.Rect(650, 50, 200, 45),
        "set_sf": pygame.Rect(650, 110, 200, 45),
        "set_obs": pygame.Rect(650, 170, 200, 45),
        "undo": pygame.Rect(650, 230, 95, 45),
        "redo": pygame.Rect(755, 230, 95, 45),
        "solve": pygame.Rect(650, 290, 200, 45)
    }

    path = None
    solved = False

    while True:
        SCREEN.fill(COLOR_BG)

        draw_grid(rows, cols, cs, grid)

        if solved and path:
            # draw_numbers(path, cs)
            draw_path(path, cs)

        hover_alpha = {name: 0 for name in buttons}  # 0 = normal, 1 = fully hovered

        for name, rect in buttons.items():
            mx, my = pygame.mouse.get_pos()

            hovered = rect.collidepoint((mx, my))

            # update animasi
            if hovered:
                hover_alpha[name] = min(1, hover_alpha[name] + 0.15)
            else:
                hover_alpha[name] = max(0, hover_alpha[name] - 0.15)

            base = COLOR_BTN
            highlight = (150, 255, 150)

            color = lerp_color(base, highlight, hover_alpha[name])

            button_labels = {
                "home": "HOME",
                "set_sf": "Set Start/Finish",
                "set_obs": "Add Obstacle",
                "undo": "Undo",
                "redo": "Redo",
                "solve": "Solve"
            }


            pygame.draw.rect(SCREEN, color, rect, border_radius=6)
            label = button_labels[name]
            SCREEN.blit(FONT.render(label, True, (255,255,255)),
                (rect.x+10, rect.y+10))

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()

            if event.type == pygame.MOUSEBUTTONDOWN:
                x,y = event.pos

                if x < cols*cs and y < rows*cs:
                    r = y // cs
                    c = x // cs

                    # save full state snapshot BEFORE making change
                    undo.append(make_snapshot(grid, start, finish, obs_count))
                    redo.clear()

                    if mode == "set_sf":
                        # placing start / finish: ensure we replace previous 'A' if needed
                        if not start and grid[r][c] == "0":
                            start = (r,c)
                            grid[r][c] = "A"
                        elif not finish and (r,c) != start and grid[r][c] == "0":
                            finish = (r,c)
                            grid[r][c] = "A"

                    elif mode == "set_obs":
                        if grid[r][c] == "0" and obs_count < max_obs:
                            grid[r][c] = "X"
                            obs_count += 1

                else:
                    for name, rect in buttons.items():
                        if rect.collidepoint(event.pos):
                            if name == "home":
                                return
                            elif name == "set_sf":
                                mode = "set_sf"
                            elif name == "set_obs":
                                mode = "set_obs"
                            elif name == "undo":
                                if undo:
                                    # push current state to redo, then restore last undo
                                    redo.append(make_snapshot(grid, start, finish, obs_count))
                                    snap = undo.pop()
                                    grid, start, finish, obs_count = restore_snapshot(snap)
                            elif name == "redo":
                                if redo:
                                    # push current state to undo, then restore next redo
                                    undo.append(make_snapshot(grid, start, finish, obs_count))
                                    snap = redo.pop()
                                    grid, start, finish, obs_count = restore_snapshot(snap)
                            elif name == "solve":
                                if start and finish:
                                    path = dfs_solver(grid)
                                    if path is None:
                                        show_alert("No solution found!")
                                    else:
                                        solved = True

        pygame.display.update()


# =============================
# MAIN
# =============================
def main():
    while True:
        r, c, o = start_menu()
        main_editor(r, c, o)


if __name__ == "__main__":
    main()
